<!DOCTYPE html>
<html>
<head>
	<title>Selectors</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <link href='http://fonts.googleapis.com/css?family=Nunito:400,300' rel='stylesheet' type='text/css'>
  <link rel="stylesheet" href="css/style.css">
	<style>
		body {
			font-family: 'Nunito', sans-serif;
			color: #616161;
			padding: 40px 0;
		}
		h1 {
      text-align: center;
    }
		ul {
			list-style: none;
			width: 50%;
			margin: auto;
		}
		li {
			border-bottom: 1px dotted #40918c;
			padding: 15px 10px;
		}
	</style>
</head>
<body>
  
  <h1>My list of items</h1> <!--But if you go back and add another element to the body, so for example this h1 element. Notice how the only-child selector no longer targets the unordered list, because now it's no longer the only-child of the body element. The h1 is now sibling of the ul.-->
  
  <!--So we can say that all 10 of these li elements are children of this parent ul.-->
  
	<ul>
		<li>Item 1</li>
		<li>Item 2 <span>&check;</span></li> <!--Let add a span element to a second list item. So right after the item 2 let's nest a span element, and this span element, will contain an HTML character entity that will display a check mark. So we typed ampersand, followed by the word check, and a semicolon.-->
		<li>Item 3</li>
		<li>Item 4</li>
		<li>Item 5</li>
		<li>Item 6  <span>&check;</span></li> <!--Let's copy this span element and nest it inside another list item. When you refresh the page you can see how the browser targets the only child span element,we had just added inside those list items. Because, as we can see here, they have no siblings elements, they're the only child inside their parent list item. -->
		<li>Item 7</li>
		<li>Item 8</li>
		<li></li> <!--We delete the text item 9 in order to have an empty elements and apply our empty pseudo class.-->
		<li>Item 10</li>		
	</ul>
</body>
</html>